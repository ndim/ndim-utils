#!/usr/bin/python


prog = 'watch-xsel'


version_fmt = """\
%(prog)s (@PACKAGE_NAME@) @PACKAGE_VERSION@
Copyright (C) 2014 Hans Ulrich Niedermann
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
"""


usage_fmt = """\
Usage: %(prog)s
       %(prog)s --urls > urls.txt
       %(prog)s --urls --unique > urls.txt
       %(prog)s --unique --append=urls.txt
       %(prog)s --unique --append urls.txt

Watch the X11 selection and print it on stdout or append to a given
file, (possibly filtered). If stdout is redirected into a file or when
appending it to a given file, the results are also printed on stderr.

Arguments:
    --help         Print this usage information and exit
    --version      Print version information and exit

    --append=FILE  Append to the given FILE.
    --unique       Ignore the new value if it has been printed before, or,
                   when appending to a FILE, if it has appeared in FILE.
    --urls         Only pass URLs (ftp, http, https)
    --verbose      Verbose debug output
"""


import re
import subprocess
import sys
import time


verbose = False


from abc import abstractmethod, ABCMeta


class InvalidArgumentError(RuntimeError):

    def __init__(self, arg):
        super(InvalidArgumentError, self).__init__('Invalid command line argument: %s' % repr(arg))


class Filter(object):

    __metaclass__ = ABCMeta

    def __init__(self, next_filter):
        super(Filter, self).__init__()
        self.next_filter = next_filter

    @abstractmethod
    def process(self, item):
        raise NotImplementedError()

    def __str__(self):
        return "%s(next=%s)" % (self.__class__.__name__, self.next_filter)


class UrlFilter(Filter):

    def __init__(self, next_filter):
        super(UrlFilter, self).__init__(next_filter)
        self.r = re.compile(r'^(ftp|https?)://', re.IGNORECASE)

    def process(self, item):
        m = self.r.match(item)
        if m:
            self.next_filter.process(item)


class UniqueFilter(Filter):

    def __init__(self, next_filter, init_fname=None):
        super(UniqueFilter, self).__init__(next_filter)
        self.d = {}
        if init_fname:
            no = 1
            for line in open(init_fname, "Ur").readlines():
                sline = line.rstrip('\r\n')
                self.d[sline] = True
                global verbose
                if verbose:
                    print "%4d" % no, repr(sline)
                    no = no + 1

    def process(self, item):
        if item not in self.d:
            self.d[item] = True
            self.next_filter.process(item)


class NewlineFilter(Filter):

    def process(self, item):
        if len(item) >= 1 and item[-1] != '\n':
            self.next_filter.process('%s\n' % item)
        else:
            self.next_filter.process(item)


class OutputFilter(Filter):

    def __init__(self, out_fname = None):
        super(OutputFilter, self).__init__(None)
        self.out_fname = out_fname
        if not out_fname:
            self.out = sys.stdout
            self.stderr_echo = sys.stderr.isatty() and not sys.stdout.isatty()
        else:
            self.out = None
            self.stderr_echo = sys.stderr.isatty()

    def process(self, item):
        if not self.out:
            self.out = open(self.out_fname, "a")
        self.out.write(item)
        self.out.flush()
        if self.stderr_echo:
            sys.stderr.write(item)
            sys.stderr.flush()

    def __str__(self):
        if self.out_fname:
            return "%s(out=%s)" % (self.__class__.__name__, repr(self.out_fname))
        else:
            return "%s(out=%s)" % (self.__class__.__name__, 'sys.stdout')


class Main(object):

    def __init__(self, args):
        super(Main, self).__init__()

        global verbose

        append_fname  = None
        filter_urls   = False
        filter_unique = False

        i = 0
        while i < len(args):
            arg = args[i]
            if False:
                pass
            elif arg in ['--help']:
                self.print_usage()
                sys.exit(0)
            elif arg in ['--version']:
                self.print_version()
                sys.exit(0)
            elif arg in ['--append']:
                assert(not(append_fname))
                i = i + 1
                append_fname = args[i]
            elif arg.startswith("--append="):
                assert(not(append_fname))
                append_fname = arg.split("=", 1)[1]
            elif arg in ['--unique']:
                assert(not(filter_unique))
                filter_unique = True
            elif arg in ['--urls']:
                assert(not(filter_urls))
                filter_urls = True
            elif arg in ['--verbose']:
                assert(not(verbose))
                verbose = True
            else:
                raise InvalidArgumentError(arg)
            i = i + 1

        self.first_filter = NewlineFilter(OutputFilter(append_fname))
        if filter_urls:
            self.first_filter = UrlFilter(self.first_filter)
        if filter_unique:
            self.first_filter = UniqueFilter(self.first_filter, append_fname)

        # http://foo.bar/bleh

        if verbose:
            print "Filters:"
            f = self.first_filter
            while True:
                print "  *", f
                if not f.next_filter:
                    break
                f = f.next_filter


    def main_loop(self):
        last_sel = ''
        while True:
            next_sel = subprocess.check_output(['xsel', '-o'],
                                               universal_newlines=True)
            if last_sel != next_sel:
                last_sel = next_sel
                self.first_filter.process(last_sel)
            time.sleep(0.5)


    def print_usage(self):
        global usage_fmt
        sys.stdout.write(usage_fmt % globals())


    def print_version(self):
        global version_fmt
        sys.stdout.write(version_fmt % globals())


if __name__ == '__main__':
    Main(sys.argv[1:]).main_loop()
