#!/bin/sh
#
# Generate some basic versioning information which can be piped to a header.
#
# Copyright (c) 2006-2007 Luc Verhaegen <libv@skynet.be>
# Copyright (C) 2007 Hans Ulrich Niedermann <hun@n-dimensional.de>
#
#
# Simple testing of this script:
#   /sbin/busybox sh git_version.sh --example > moo.c \
#     && gcc -Wall -Wextra -Wno-unused -o moo moo.c \
#     && ./moo
#   (bash should also do)

# The caller may have found these programs for us
EGREP="${EGREP-"grep -E"}"
SED="${SED-sed}"

# Initialize
GIT_DIR=".git"
working_dir="$(pwd)"

# Who am I?
self="$(basename "$0")"

# Defaults
ifndef_symbol="GIT_VERSION_H"
outfile="-"
print_example=false
srcdir="$(pwd)"

# Parse command line parameter, affecting defaults
while [ "x$1" != "x" ]
do
    case "$1" in
        --example)
            print_example=:
            ;;
        -o|--output)
            if shift; then
                outfile="$1"
                if [ "x$outfile" = "x-" ]; then
                    : # keep default ifndef_symbol
                else
                    ifndef_symbol=`basename "$outfile" | $SED 's|\.|_|g; s|[^A-Za-z0-9_]||g' | tr a-z A-Z`
                fi
            else
                echo "$self: Fatal: \"$1\" option requires parameter." >&2
                exit 1
            fi
            ;;
        --help)
            echo "Supported params: --help, --example, -o|--output"
            exit
            ;;
	-s|--srcdir)
	    if shift; then
		if test -d "$1"; then
		    srcdir="$1"
		else
		    echo "$self: Fatal: \"$1\" not a directory."
		    exit 1
		fi
	    else
		echo "$self: Fatal: \"$1\" option requires directory parameter."
		exit 1
	    fi
	    ;;
        *)
            echo "$self: Fatal: Invalid command line paramenter: \"$1\"" >&2
            exit 1
            ;;
    esac
    shift
done

# If not printing to stdout, redirect stdout to output file
rename_new_output=false
if [ "x$outfile" = "x-" ]
then
    : # keep using stdout
else
    exec 1> "${outfile}.new"
fi

# Done with creating output files, so we can change to source dir
cd "$srcdir"

# Write program header
cat<<EOF
/*
 * Basic versioning gathered from the git repository.
 * Automatically generated by $0.
 */

#ifndef ${ifndef_symbol}
#define ${ifndef_symbol} 1

EOF

# Determine and write git specific defines
git_tools=`which git-whatchanged`
if [ "x$git_tools" != "x" ]; then
    if [ -e "$GIT_DIR/index" ]; then
        echo "/* This is a git repository */"
        echo "#define GIT_USED 1"
        echo ""

        # Commit SHA-ID
        git_shaid=`git-whatchanged | $SED -n '1s/^commit \(.\{8\}\).*/\1/p'`
        echo "/* Git SHA ID of last commit */"
        echo "#define GIT_SHAID \"${git_shaid}..\""
        echo ""

        # Branch -- use git-status instead of git-branch
        git_branch=`git-status | $SED -n 's/^#\ On\ branch\ \(.*\)/\1/p'`
        if [ "x$git_branch" = "x" ]; then
            git_branch=`git-branch | $SED -n 's/^* //p'`
        fi
        if [ "x$git_branch" = "x" ]; then
            git_branch="<<unknown/master>>"
        fi
        echo "/* Branch this tree is on */"
        echo "#define GIT_BRANCH \"$git_branch\""
        echo ""

        # Any uncommitted changes we should know about?
        git_uncommitted=`git-status | $EGREP "(Changed but not updated|Updated but not checked in|Changes to be committed)"`
        if [ "x$git_uncommitted" != "x" ]; then
            echo "/* Local changes might be breaking things */"
            echo "#define GIT_UNCOMMITTED 1"
        else
            echo "/* SHA-ID uniquely defines the state of this code */"
            echo "#undef GIT_UNCOMMITTED"
        fi
    else
        echo "/* This is not a git repository */"
        echo "#undef GIT_USED"
    fi
else
    echo "/* git is not installed */"
    echo "#undef GIT_USED"
fi

# Define a few immediately useful message strings
cat<<EOF

/* Define GIT_MESSAGE such that
 *    printf("%s: built from %s", argv[0], GIT_MESSAGE);
 * forms a proper sentence.
 */

#ifdef GIT_USED

# ifdef GIT_UNCOMMITTED
#  define GIT_WITH_WITHOUT_UNCOMMITTED " + changes"
# else
#  define GIT_WITH_WITHOUT_UNCOMMITTED ""
# endif /* GIT_UNCOMMITTED */

# define GIT_MESSAGE \\
        "git branch " GIT_BRANCH ", " \\
        "commit " GIT_SHAID GIT_WITH_WITHOUT_UNCOMMITTED

#else
# define GIT_MESSAGE "non-git sources"
#endif /* GIT_USED */

#endif /* ${ifndef_symbol} */
EOF

# Example program
if "$print_example"
then
    cat<<EOF

/* example program demonstrating the use of git_version.sh output */
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
    const char *const idx = strrchr(argv[0], '/');
    const char *const prog = (idx)?(idx+1):(argv[0]);
#ifdef PACKAGE_VERSION
    printf("%s: version %s, built from %s\n", prog, PACKAGE_VERSION, GIT_MESSAGE);
#elif defined(GIT_USED)
    printf("%s: built from %s\n", prog, GIT_MESSAGE);
#endif
    return 0;
}
EOF
fi

# Change back to working dir for the remaining output file manipulations.
cd "$working_dir"

# If necessary, overwrite outdated output file with new one
if [ "x$outfile" != "x-" ]
then
    if [ -f "$outfile" ]; then
        if cmp "$outfile" "$outfile.new" > /dev/null; then
            echo "$self: Output is unchanged, keeping $outfile" >&2
            rm -f "$outfile.new"
        else
            echo "$self: Output has changed, updating $outfile" >&2
            mv -f "$outfile.new" "$outfile"
        fi
    else
        mv -f "$outfile.new" "$outfile"
    fi
fi

# THE END.
